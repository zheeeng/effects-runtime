\nimport type { vec4 } from \'@types/gl-matrix\';\nimport type { RGBAColorValue } from \'./text-plugin-spec\';\n\ninterface StrokeEffect {\n    type: \'stroke\';\n    color: RGBAColorValue;\n    width: number;\n}\n\ninterface ShadowEffect {\n    type: \'shadow\';\n    color: RGBAColorValue;\n    blur: number;\n    offsetX: number;\n    offsetY: number;\n}\n\ninterface GradientEffect {\n    type: \'gradient\';\n    stops: { offset: number; color: RGBAColorValue }[];\n    direction: vec4; // [startX, startY, endX, endY]\n}\n\ninterface GlowEffect {\n    type: \'glow\';\n    color: RGBAColorValue;\n    blur: number;\n    strength: number;\n}\n\nexport type FancyTextEffect = StrokeEffect | ShadowEffect | GradientEffect | GlowEffect;\n\nexport function renderFancyEffects(ctx: CanvasRenderingContext2D, text: string, x: number, y: number, options: { font: string; fillStyle: string | CanvasGradient | CanvasPattern; strokeStyle: string | CanvasGradient | CanvasPattern; lineWidth: number; shadowColor: string | null; shadowBlur: number; shadowOffsetX: number; shadowOffsetY: number; }, effects: FancyTextEffect[]) {\n    // Save the original context state\n    ctx.save();\n\n    // Apply effects in order. The order in the array determines the rendering order (first = bottom layer, last = top layer).\n    for (const effect of effects) {\n        // Save context state for each effect to isolate changes\n        ctx.save();\n\n        switch (effect.type) {\n            case \'stroke\':\n                // Render stroke\n                ctx.strokeStyle = \`rgba(\${effect.color.join(',')})\`;\n                ctx.lineWidth = effect.width;\n                ctx.strokeText(text, x, y);\n                break;\n            case \'shadow\':\n                // Render shadow\n                ctx.shadowColor = \`rgba(\${effect.color.join(',')})\`;\n                ctx.shadowBlur = effect.blur;\n                ctx.shadowOffsetX = effect.offsetX;\n                ctx.shadowOffsetY = effect.offsetY;\n                // To ensure shadow is applied correctly, we might need to re-fill the text with a transparent color or the base text color.\n                // For simplicity here, we assume the base fill/stroke is already applied or will be applied after effects.\n                // A more robust solution would handle the fill/stroke within each effect.\n                ctx.fillText(text, x, y);\n                break;\n            case \'gradient\':\n                // Render gradient fill\n                const gradient = ctx.createLinearGradient(effect.direction[0], effect.direction[1], effect.direction[2], effect.direction[3]);\n                effect.stops.forEach(stop => {\n                    gradient.addColorStop(stop.offset, \`rgba(\${stop.color.join(',')})\`);\n                });\n                ctx.fillStyle = gradient;\n                ctx.fillText(text, x, y);\n                break;\n            case \'glow\':\n                // Render glow effect using shadowBlur\n                ctx.shadowColor = \`rgba(\${effect.color.join(',')})\`;\n                ctx.shadowBlur = effect.blur;\n                // Glow might need multiple passes or specific compositing operations for a better effect.\n                // For simplicity, using shadowBlur with a slight offset might suffice for basic glow.\n                ctx.shadowOffsetX = 0;\n                ctx.shadowOffsetY = 0;\n                ctx.fillText(text, x, y);\n                break;\n        }\n\n        // Restore context state after applying the effect\n        ctx.restore();\n    }\n\n    // Restore the original context state\n    ctx.restore();\n}\n